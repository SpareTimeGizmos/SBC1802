	.TITLE	EEPROM Update Utility for SBC1802
	.SBTTL	Bob Armstrong [9-AUG-2024]

;++
;       Copyright (C) 2024 By Spare Time Gizmos, Milpitas CA.
;
;   This program is free software; you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation; either version 2 of the License, or
; (at your option) any later version.
;
;   This program is distributed in the hope that it will be useful, but
; WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
; for more details.
;
;   You should have received a copy of the GNU General Public License along
; with this program; if not, write to the Free Software Foundation, Inc.,
; 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
;--
;0000000001111111111222222222233333333334444444444555555555566666666667777777777
;1234567890123456789012345678901234567890123456789012345678901234567890123456789

;++
;   This little piece of code updates the SBC1802 firmware by copying the code
; from RAM to EEPROM.  This code is constrained to 256 bytes and lives in the
; EPROM image from $FE00 to $FEFF.  This is the ROM space that's shadowed by
; the monitor RAM and memory mapped peripherals, and normally this part of ROM
; can never be accessed.
;
;   The basic plan for an in situ update of the SBC1802 firmware goees like
; this -
;
;   Step 0 - make sure your EEPROM wasn't software write protected when you
;	programmed it!  Next, make sure the EEPROM write enable jumper JP1
;	is installed.
;
;   Step 1 - boot up the old firmware.  Hopefully it still works!
;
;   Step 2 - download the new firmware image to RAM from $0000 to $7FFF
;	using either the XLOAD command or the Intel .HEX file downloader.
;	Note that, although the code actually lives at $8000 to $FFFF,
;	the firmware HEX file is origined to $0000 so the Intel HEX loader
;	will work just fine.  If you want to use XLOAD, you'll have to
;	convert the HEX file to a pure binary image first.
;
;   Step 3 - use the "CHECKSUM 0 7FFF" command to verify the download.  The
;	checksum you get should agree with that generated by ROMCKSUM.
;
;   Step 4 - issue the command "RUN 7E00".  That will start the update code
;	running and it will take care of the rest!   Note - "CALL 7E00" works
;	in this case too ...
;
;   Step 5 - when the update has finished, remove JP1 and RESET the SBC1802.
;
;   The basic plan here is to change the memory map back to ROM0 (remember that
; the CALL command will start us with either the ElfOS or MicroDOS map!), copy
; all the bytes from $0000 to $7FFF to EEPROM at $8000 to $FFFF, and verify
; each byte as it is copied. The only caveat is that we have to skip copying
; the chunk from $7E00 to $7EFF, because that would overwrite monitor RAM and
; the memory mapped peripherals (including the MCR!).
;
;   Note that we can't access any of the code in ROM while we're updating
; because the EPROM chip will be "offline" while it's busy updating each byte.
; Because we want to issue progress messages while we're updating, we have
; a super simple console output routine here that's called via a "SEP MSGPC".
; There's no SCRT and don't even think of trying to use CALL or RETURN.  The
; stack pointer, SP, is initialized to $7EFF and gives us a byte or two of
; temporary storage.
;
;   BTW, I can almost hear you thinking - "We can't access EEPROM, but we have
; a copy of all that code in RAM while we're here, right?  Why not use that
; for console I/O and other good stuff??"   That's true, we do have a complete
; copy of the BIOS and everything else in RAM right now, but that code contains
; subroutine CALLs and long branch instructions which have the WRONG MSB in the
; upper address byte.  The only thing you could conceivably call is a routine
; that a) doesn't call anything else, and b) only contains short branches.
; Don't bother - it's not worth it!
;
;   And lastly a word about checksums.  This code gets merged into the EPROM
; image before the ROM checksum is calculated, so that checksum includes this
; code.  Fine, because POST F (the ROM test code) verifies the checksum using
; the boot map so the entire image is checksummed, once again including this
; code.   But suppose at some point there's a new version of the firmware,
; with the corresponding new EPROM image and a different checksum.   When that
; gets downloaded to the SBC1802 and the EEPROM updated using this code, this
; code is NOT copied to the EEPROM.  We can't copy it, remember?  It's shadowed
; by the monitor RAM and memory mapped peripherals.
;
;   So the POSTF will fail after the EEPROM is updated, right?  Well, maybe.
; Remember that the original version of this code is still in that EEPROM -
; it isn't erased after all - so as long as the updater code in the new image
; is the same as that in the old image, the checksum will still be valid.
; You'll only run into a problem if you change this specific updater code.
; Yes, it's a kludge, but it kind of works.
;--

	.MSFIRST \ .PAGE \ .CODES
	.NOLIST
	.INCLUDE "sbc1802.inc"	; SBC1802 hardware and environment definitions
	.LIST

; Definitions ...
MSGPC	.EQU	RETPC		; PC used for the INLMSG routine
#define	MSG(str)	SEP MSGPC\ .TEXT str \ .BYTE 0


;++
;   This is the startup code.  We initialize R3 as the PC (it may be already,
; depending on whether we're started with a RUN or CALL), but we'll change it
; just to be sage.  Then initialize the MSGPC routine, the stack pointer, and
; select the ROM0 memory map (currently either ElfOS or MicroDOS is selected).
; Lastly, be sure the base board I/O group is selected for the console I/O.
;
;   And remember - this code lives in page $FExx but it actually runs from
; page $7Exx ...
;--
	.ORG	DPBASE			; $FE00 ...
	RLDI(PC, UPDATE & $7FFF)	; set R3 as the PC
	SEP	PC			; ...
UPDATE:	RLDI(MSGPC, INLMSG & $7FFF)	; MSGPC points to the console output
	RLDI(SP, TSTACK & $ 7FFF)	; set up a temporary stack
	RLDI(T1,MCR)			; point to the memory control register
	LDI MC.ROM0\ STR T1		; and select the ROM0 memory map
	OUTI(GROUP,BASEGRP)		; lastly, select the base board I/O

;++
;   The first pass copies all the code, excepting page $7Exx, from RAM to
; EEPROM.  Every time we write a byte to the EEPROM it will automatically
; erase that location first and then update it with the new data.  This
; process takes about 5ms (yes, milliseconds!) and we wait for the EEPROM to
; finish by constantly polling that same location.  When we can read back
; what we wrote, then we know it's done.  Conversely, if the EEPROM has failed
; or you've forgotten to put in the write enable jumper, or if the EEPROM is
; really an EPROM, then this will never happen and we'll loop here forever.
; There's no time out, so don't mess up!
;--
	MSG("Writing ...")	; give a status message
	RCLR(T1)\ RLDI(T2,$8000); T1 points to RAM, T2 points to EEPROM
CPYLP:	GHI T2\ XRI HIGH(DPBASE); DON'T copy page $FExx!!
	BZ	CPYLP2		; ...
	LDN T1\ STR T2\ STR SP	; copy one byte
CPYLP1:	SEX SP\ LDN T2\ XOR	; read back and compare
	BNZ	CPYLP1		; loop until they're the same
CPYLP2:	INC T1\ INC T2		; on to the next byte
	GLO T2\ BNZ CPYLP3	; print a "." every 1K bytes
	GHI T2\ ANI 3\ BNZ CPYLP3; ...
	MSG(".")		;  ...
CPYLP3:	GHI T2\ BNZ CPYLP	; loop until $FFFF rolls over to $0000
	MSG(" OK\015\012")	; give a status message

;++
;   In the second pass we read back everything in EEPROM and compare it to
; what's in RAM.  Strictly speaking this step isn't necessary (we compared
; everything byte by byte above, after all) but it's an extra safety step
; just to be sure.
;--
	MSG("Verifying ...")
	RCLR(T1)\ RLDI(T2,$8000); T1 points to RAM, T2 points to EEPROM
VFYLP:	GHI T2\ XRI HIGH(DPBASE); DON'T verify page $FExx!!
	BZ	VFYLP2		; ...
	SEX T1\ LDN T2\ XOR	; compare one byte
	BNZ	VFYERR		; branch if they don't match
VFYLP2:	INC T1\ INC T2		; on to the next byte
	GHI T2\ BNZ VFYLP	; loop until $FFFF rolls over to $0000
	MSG(" OK\015\012")	; give a status message

;++
;   All done!!   Print a final message and then execute an IDL instruction.
; This will turn off the RUN LED on the SBC1802, and we'll wait for the user
; to press the reset button.
;--
	MSG("Remove JP1 and")
	MSG(" RESET\015\012")
	IDL\ BR $-1

;++
;   Here if there's a verification error.  We'll just go back and restart the
; entire programming process.  Maybe it'll work the second time, and maybe not,
; but there's not much else we can do!
;--
VFYERR:	MSG(" ERROR\015\012")
	BR	UPDATE
	.SBTTL	Utility Routines

;++
;   This simple routine prints a string on the console terminal.  It's called
; via a SEP MSGPC, returns via SEP PC, and expects the string to be passed
; inline.  Note that this assumes the console serial port has already been
; initialized, probably by the old firmware...
;
;CALL:
;	SEP	MSGPC
;	.TEXT	"string\000"
;	<return here>
;--
MSG2:	SEP	PC		; return and leave MSGPC set up
INLMSG:	LDA PC\ BZ MSG2		; return when we find a null
	SEX SP\ PUSHD		; save the character 
MSG1:	INP SL0STS\ ANI SL.THRE	; is the transmitter busy?
	BZ	MSG1		; wait if it is
	IRX\ OUT SL0BUF\ DEC SP	; type the original character
	BR	INLMSG		; keep typing

; Temporary stack ...
TSTACK .EQU	($ & $FF00) + $FF

	.END
